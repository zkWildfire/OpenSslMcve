# OpenSSL XMM Register Bug MCVE
## Overview
This project implements a minimum complete verifiable example used to reproduce
a bug in OpenSSL's assembly code for the x86_64 architecture. The bug is
triggered by running poly1305 methods on a CPU chip that supports AVX-512
instructions and is **not** a Skylake-derived architecture. When this bug
occurs, it results in the XMM registers in the range XMM6-XMM15 getting cleared
and not restored. This can then cause miscellaneous other errors and unexpected
behavior if the compiler has generated other code that expects those registers
to have been restored correctly.

## Prerequisites
* Visual Studio or the Visual Studio build tools
  * This MCVE was tested with Visual Studio 2022. It's likely that any recent
    version of Visual Studio will work, but the exact minimum version is not
    known.
* Python 3
  * This MCVE was tested using Python 3.11. The exact minimum required version
    is not known, but it must be later than v3.4.

## Setup
This bug only occurs on Windows. To run the MCVE, you will need to have Visual
Studio installed and locatable by vswhere.exe, or you will need to have the
Visual Studio build tools installed and run commands in a terminal in which
the `vsdevcmd.bat` script has been run. To handle first time setup, run the
`init.ps1` script (which may require you to configure your powershell execution
policy). Once the script has completed, run `build.bat` to build the project.

This bug requires the following conditions to be met in order to reproduce the
bug:

* The CPU must support AVX-512F instructions
    * The bug only occurs when using the AVX-512 code path in the poly1305 code,
      which requires a CPU to support the AVX-512F instruction set.
* The CPU must **not** be a Skylake-derived architecture
    * OpenSSL disables the AVX-512 code path on Skylake-X for performance
      reasons, so the AVX-512 code path doesn't get taken on those CPUs
    * Note that this applies for any Skylake X or Skylake X-derived architecture.
      For example, Cascade Lake CPUs will not encounter this bug because Cascade
      Lake is based on Skylake.
    * See `x86_64cpuid.asm:186` (created during the build process of OpenSSL)
      for where AVX-512 support is suppressed on Skylake-derived architectures
    * Also see `crypto/poly1305/asm/poly1305-x86_64.pl` in the OpenSSL source
      code for further details on why the AVX-512 code path is not used on
      Skylake X-derived architectures
* The host OS must be Windows
    * This bug occurs as a result of failing to follow the x64 calling
      convention on Windows.
* A method must be called that uses the poly1305 algorithm internally
    * The relevant poly1305 methods aren't directly exposed in the OpenSSL API,
      so this test app uses the chacha20_poly1305 cipher to trigger the bug
* The poly1305 methods must be called with a buffer that is above some threshold
  (presumably 512 bits) to trigger the bug
    * If the buffer being processed is below the threshold, then the AVX-512
      code path is not taken and the bug does not occur

To build this app, download the repository and run `init.ps1` to download and
set up dependencies. Then, run `build.bat debug` or `build.bat release` to
build the app. The bug will reproduced in either mode on a CPU that meets the
above conditions since the bug is in OpenSSL's generated assembly code rather
than code generated by the compiler. The binary will be written to `_out/[build-type]/MCVE.exe` and can be run with no arguments.

## Context
The x64 calling convention on Windows specifies that registers XMM6-XMM15 are
"non-volatile" or "callee-saved" ([source](https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170#callercallee-saved-registers)). This
means that the state of the registers before and after a method call is required
to be the same. However, when the AVX-512 code path is taken in OpenSSL's
poly1305 code, the registers XMM6-XMM15 get zeroed out during the method call
and are not restored to their original values. This is demonstrated by this
test app, which dumps the state of all XMM registers before and after various
calls to OpenSSL to show that the registers are not restored correctly.

## Reproducing the Bug
If your system's CPU meets the requirements, you can reproduce the bug by
running the app directly. If your CPU does not meet the requirements, you can
still reproduce this issue locally by using Intel's Software Development
Emulator to emulate a CPU that meets the requirements. See the [Emulating
Affected CPUs](#emulating-affected-cpus) section for more details.

The app will encrypt and decrypt a small message first, which uses a buffer
that is too small to trigger the bug. This is used as a sanity check to show
that registers are restored correctly when not using the buggy code path. For
this section, you should see the following output:

```
Pre-Encrypt short string register state:
XMM0: 0 0 0 0
XMM1: 0 0 0 0
XMM2: 0 0 0 0
XMM3: 0 0 0 0
XMM4: 0 0 0 0
XMM5: 0 0 0 0
XMM6: 24 25 26 27
XMM7: 28 29 30 31
XMM8: 32 33 34 35
XMM9: 36 37 38 39
XMM10: 40 41 42 43
XMM11: 44 45 46 47
XMM12: 48 49 50 51
XMM13: 52 53 54 55
XMM14: 56 57 58 59
XMM15: 60 61 62 63

Post-Encrypt short string register state:
XMM0: 0 0 0 0
XMM1: 0 0 0 0
XMM2: 0 0 0 0
XMM3: 0 0 0 0
XMM4: 0 0 0 0
XMM5: 0 0 0 0
XMM6: 24 25 26 27
XMM7: 28 29 30 31
XMM8: 32 33 34 35
XMM9: 36 37 38 39
XMM10: 40 41 42 43
XMM11: 44 45 46 47
XMM12: 48 49 50 51
XMM13: 52 53 54 55
XMM14: 56 57 58 59
XMM15: 60 61 62 63
```

Notice how for XMM6-XMM15, the values are the same before and after the method
call. This is expected behavior.

Next, the app will encrypt and decrypt a string sufficiently long to trigger
the bug. For this section, you should see the following output:

```
Pre-Encrypt long string register state:
XMM0: 0 0 0 0
XMM1: 0 0 0 0
XMM2: 0 0 0 0
XMM3: 0 0 0 0
XMM4: 0 0 0 0
XMM5: 0 0 0 0
XMM6: 24 25 26 27
XMM7: 28 29 30 31
XMM8: 32 33 34 35
XMM9: 36 37 38 39
XMM10: 40 41 42 43
XMM11: 44 45 46 47
XMM12: 48 49 50 51
XMM13: 52 53 54 55
XMM14: 56 57 58 59
XMM15: 60 61 62 63

Post-Encrypt long string register state:
XMM0: 0 0 0 0
XMM1: 0 0 0 0
XMM2: 0 0 0 0
XMM3: 0 0 0 0
XMM4: 0 0 0 0
XMM5: 0 0 0 0
XMM6: 0 0 0 0
XMM7: 0 0 0 0
XMM8: 0 0 0 0
XMM9: 0 0 0 0
XMM10: 0 0 0 0
XMM11: 0 0 0 0
XMM12: 0 0 0 0
XMM13: 0 0 0 0
XMM14: 0 0 0 0
XMM15: 0 0 0 0
```
Unlike the previous section, the values for XMM6-XMM15 are not the same before
and after the method call. This shows that the bug was triggered and that the
x64 calling convention was violated.

## Emulating Affected CPUs
If your CPU does not meet the requirements to reproduce the bug, you can use
Intel's Software Development Emulator (SDE) to emulate a CPU that does meet the
requirements. To do this, first download the SDE from this link:

https://www.intel.com/content/www/us/en/developer/articles/tool/software-development-emulator.html

Extract the contents of the downloaded file, which should contain `sde.exe`.
You can then run the MCVE app via SDE by running the following commands:

```sh
# To run the app directly, pass the path to the app binary to SDE
sde -tgl -- MCVE.exe

# Or, run cmd.exe (or powershell) via SDE. This will cause any process launched
#   from the resulting command prompt to run under SDE
sde -tgl -- cmd.exe
```

Using `-tgl` will cause SDE to emulate a Tiger Lake CPU, which is an AVX-512
capable processor on which the bug occurs. You can also use `-skl` to emulate
a Skylake processor or `-csl` to emulate a Cascade Lake processor, neither of
which are affected by this bug.

## Debugging
> All debugging occurred on an Intel Tiger Lake machine running Windows 11.

* Issue is with the call to `poly1305_blocks()` at `poly1305.c:500`
* Code blocks for saving the XMM registers are present at:
    * `$L$do_avx` (`poly1305-x86_64.asm:708`)
    * `$L$skip_avx512` (`poly1305-x86_64.asm:1652`)
    * `$L$blocks_avx512` (`poly1305-x86_64.asm:2053`)
* Code blocks for restoring the XMM registers are present at:
    * `$L$short_tail_avx` (`poly1305-x86_64.asm:1276`)
    * `$L$tail_avx2` (`poly1305-x86_64.asm:2016`)
* Code flow in `poly1305_blocks()`:
    * `poly1305_blocks_vpmadd52` (`poly1305-x86_64.asm:2660`)
    * `$L$blocks_vpmadd52_4x` (`poly1305-x86_64.asm:2803`)
        * Jumped to from `poly1305-x86_64.asm:2692`
    * `$L$init_vpmadd52` (`poly1305-x86_64.asm:2859`)
        * Jumped to from `poly1305-x86_64.asm:2812`
        * Execution loops by jumping to `$L$mul_init_vpmadd52` (`poly1305-x86_64.asm:2872`)
        * Jump occurs from `poly1305-x86_64.asm:2948`
    * `$L$done_init_vpmadd52` (`poly1305-x86_64.asm:2952`)
        * Jumped to from `poly1305-x86_64.asm:2932`
    * `$L$blocks_vpmadd52_4x_key_loaded` (`poly1305-x86_64.asm:2827`)
        * Jumped to from `poly1305-x86_64.asm:2981`
    * `$L$blocks_vpmadd52_8x` (`poly1305-x86_64.asm:3255`)
        * Jumped to from `poly1305-x86_64.asm:2833`
    * `$L$oop_vpmadd52_8x` (`poly1305-x86_64.asm:3384`)
        * Jumped to from `poly1305-x86_64.asm:3381`
        * Execution loops more than once
        * Jump occurs from `poly1305-x86_64.asm:3461`
    * `$L$tail_vpmadd52_8x` (`poly1305-x86_64.asm:3463`)
        * Dropped into to from `$L$oop_vpmadd52_8x`
    * `$L$no_data_vpmadd52_8x` (`poly1305-x86_64.asm:3577`)
        * Dropped into to from `$L$tail_vpmadd52_8x`
* Issue appears to be with the `$L$no_data_vpmadd52_8x` label
    * A comment there mentions "WIN64 epilogue" but it doesn't contain code
      for restoring the XMM registers
    * `$L$no_data_vpmadd52_8x` is created at `poly1305-x86_64.pl:3734`
    * `x86_64-xlate.pl` is the script that transforms the code generated by
      `poly1305-x86_64.pl` into NASM assembly code
        * The xlate.pl script also adds the Win64 epilogue
        * However, xlate.pl doesn't seem to be responsible for adding the XMM
          save and restore code since that code is present in `poly1305-x86_64.pl`
* `poly1305_init()` does not save XMM registers to memory
    * Therefore, it is likely that XMM save and restore code needs to be added
      to the code executed by `poly1305_blocks()`
